#!/usr/bin/env python3

import sys
import copy
from moveit_commander import move_group
import rospy
import moveit_commander
import moveit_msgs.msg
import geometry_msgs.msg 
from math import pi, sqrt, pow
from std_msgs.msg import String
import io
import shutil
import json
#used to convert the points from the gui in a valid message for ros
from geometry_msgs.msg import Pose, PoseStamped
#used to read out the start points
import os
from nav_msgs.msg import Path
#used for publishing the planned path from start to goal
from visualization_msgs.msg import Marker, MarkerArray
#used to make a service request 
from moveit_msgs.srv import GetPositionIKRequest, GetPositionIK
from rqt_mypkg import path_planning_interface
from trajectory_msgs.msg import JointTrajectoryPoint

## StatsitcisDefinedPath is used to get the path length of given points/positions generated by the Motion Plan
class StatisticsDefinedPath(object):

    ## Returns the path length
    # @param eef_poses A list of end effector poses derived from the motion between start and goal pose
    def get_path_length(self, eef_poses):

        path_length = 0
        for i in range(len(eef_poses) - 1):
            ## @var posex
            # position x of the given position/point
            posex = eef_poses[i].position.x
            ## @var posey
            # position y of the given position/point
            posey = eef_poses[i].position.y
            ## @var posez
            # position z of the given position/point
            posez = eef_poses[i].position.z

            ## @var posex1
            # position x of the next given position/point
            posex1 = eef_poses[i+1].position.x
            ## @var posey1
            # position y of the next given position/point
            posey1 = eef_poses[i+1].position.y
            ## @var posez1
            # position z of the next given position/point
            posez1 = eef_poses[i+1].position.z

            ## @var path_length
            # formula to get the length of 2 corresponding points
            path_length += sqrt(pow((posex1 - posex), 2) + pow((posey1- posey), 2))+ pow((posez1-posez),2)
        return path_length

    ## Returns the maximum joint acceleration of every acceleration measured
    # @param motion_plan The motion plan retrieved by the planner
    def get_max_joint_acceleration(self, motion_plan):
        ## @var maxlist 
        # This list contains all accelerations given by the motion plan
        maxlist = []

        for i in range(len(motion_plan[1].joint_trajectory.points)):
            for j in range(len(motion_plan[1].joint_trajectory.points[i].accelerations)):
                for k in range(len(motion_plan[1].joint_trajectory.points[i].accelerations)):
                    maxlist.append(motion_plan[1].joint_trajectory.points[i].accelerations[j])

        return max(maxlist)